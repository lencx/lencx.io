---
title: Data structure and algorithm
date: 2020-07-23
type: technology
category:
spoiler:
tags:
# readtime:
---

### 复杂度

> 复杂度是衡量代码运行效率的重要的度量因素。分为**时间复杂度**和**空间复杂度**

* **它与具体的常系数无关**，O(n) 和 O(2n) 表示的是同样的复杂度
* **复杂度相加的时候，选择高者作为结果**，也就是说 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度
* **O(1) 也是表示一个特殊复杂度**，即任务与算例个数 n 无关

### 数据结构

> 将“昂贵”的时间复杂度转换成“廉价”的空间复杂度(常用的降低时间复杂度的方法有递归、二分法、排序算法、动态规划等)

* **暴力解法**，在没有任何时间、空间约束下，完成代码任务的开发
* **无效操作处理**，将代码中的无效计算、无效存储剔除，降低时间或空间复杂度
* **时空转换**，设计合理数据结构，完成时间复杂度向空间复杂度的转移

### 数据操作

> 数据处理的基本操作只有 3 个，分别是**增**、**删**、**查**。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。几乎所有的数据处理，都是这些基本操作的组合和叠加

* **查找**: 看能否在数据结构中查找到这个元素，也就是判断元素是否出现过
  - 根据元素的位置或索引来查找
  - 根据元素的数值特征来查找
* **新增**: 针对没有出现过的情况，新增这个元素
* **改动**: 针对出现过的情况，需要对这个元素出现的次数加 1

### 栈

> 栈是一种特殊的线性表，栈的数据结点必须后进先出

* **栈的基本操作**：压栈（push），出栈（pop）
* **栈的案例**：
  - 左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配（左括号 ==> 压栈，右括号 ==> 出栈，如果栈为空则合法）
  - 浏览器后退和前进的功能：维护两个栈，分别用来支持后退和前进。当用户访问了一个新的页面，则对后退栈进行压栈操作。当用户后退了一个页面，则后退栈进行出栈，同时前进栈执行压栈。当用户前进了一个页面，则前进栈出栈，同时后退栈压栈

### 队列

> 队列也是一种特殊的线性表，特点是先进先出。通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列，在面对数据处理顺序非常敏感的问题时，队列一定是个不错的技术选型

* **两种存储方式**：顺序队列和链式队列
  - 顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储
  - 链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表
* 循环队列：特殊变种

### 数组

> 数组是数据结构中的最基本结构。数组在内存中是连续存放的，数组内的数据，可以通过索引值直接取出得到

* **数组增删查操作的特点**
  - 增加：若插入数据在最后，则时间复杂度为 O(1)；如果中间某处插入数据，则时间复杂度为 O(n)
  - 删除：对应位置的删除，扫描全数组，时间复杂度为 O(n)
  - 查找：如果只需根据索引值进行一次查找，时间复杂度是 O(1)。但是要在数组中查找一个数值满足指定条件的数据，则时间复杂度是 O(n)

### 字符串

> 字符串（string） 是由 n 个字符组成的一个有序整体（ n >= 0 ）。字符串的存储结构与线性表相同，也有顺序存储和链式存储两种

### 树

>树是由结点和边组成的，不存在环的一种数据结构。树满足递归定义的特性。也就是说，如果一个数据结构是树结构，那么剔除掉根结点后，得到的若干个子结构也是树，通常称作子树

* 遍历
  - **前序遍历**，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树
  - **中序遍历**，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树
  - **后序遍历**，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身

#### 二叉树

> 在树的大家族中，有一种被高频使用的特殊树，它就是二叉树。在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点

* **满二叉树**：定义为除了叶子结点外，所有结点都有 2 个子结点
* **完全二叉树**：定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列

### 哈希表

> 哈希表名字源于 Hash，也可以叫作散列表。哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来（`如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想`）

* 常用的设计哈希函数的方法:
  - 直接定制法：哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数
  - 数字分析法：假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址
  - 平方取中法：如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址
  - 折叠法：如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址
  - 除留余数法：预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p
* 解决哈希冲突：
  - 开放定址法：即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中（常用的探测方法是线性探测法）
  - 链地址法：将哈希地址相同的记录存储在一张线性链表中

### 递归

> 数学模型其实就是数学归纳法。在数学与计算机科学中，递归 （Recursion)）是指在函数的定义中使用函数自身的方法，直观上来看，就是某个函数自己调用自己（`递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决`）

* 递归有两层含义:
  - 递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题。并且这些子问题可以用完全相同的解题思路来解决；
  - 归问题的演化过程是一个对原问题从大到小进行拆解的过程，并且会有一个明确的终点（临界点）。一旦原问题到达了这个临界点，就不用再往更小的问题上拆解了。最后，从这个临界点开始，把小问题的答案按照原路返回，原问题便得以解决
* 这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况
* 递归的实现包含了两个部分，一个是递归主体，另一个是终止条件
* 递归的案例：汉诺塔问题，斐波那契数列，分治策略，快速排序

### 分治法

> 分治法的核心思想就是“分而治之”。利用分而治之的思想，就可以把一个大规模、高难度的问题，分解为若干个小规模、低难度的小问题。计算机求解问题所需的计算时间，与其涉及的数据规模强相关。简而言之，问题所涉及的数据规模越小，它所需的计算时间也越少；反之亦然。分治法在每轮递归上，都包含了*分解问题*、*解决问题*和*合并结果*这 3 个步骤

* 需要采用分治法时，一般原问题都需要具备以下几个特征：
  - **难度在降低**，即原问题的解决难度，随着数据的规模的缩小而降低。这个特征绝大多数问题都是满足的
  - **问题可分**，原问题可以分解为若干个规模较小的同类型问题。这是应用分治法的前提
  - **解可合并**，利用所有子问题的解，可合并出原问题的解。这个特征很关键，能否利用分治法完全取决于这个特征
  - **相互独立**，各个子问题之间相互独立，某个子问题的求解不会影响到另一个子问题。如果子问题之间不独立，则分治法需要重复地解决公共的子问题，造成效率低下的结果
* 解题思路
  - 二分查找的时间复杂度是 O(logn)，这也是分治法普遍具备的特性。当你面对某个代码题，而且约束了时间复杂度是 O(logn) 或者是 O(nlogn) 时，可以想一下分治法是否可行
  - 二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。因此，编码的时候，多数会采用 while 循环加 break 跳出的代码结构
  - 二分查找处理的原问题必须是有序的。因此，当你在一个有序数据环境中处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了
  - 在面对陌生问题时，需要注意原问题的数据是否有序，预期的时间复杂度是否带有 logn 项，是否可以通过小问题的答案合并出原问题的答案。如果这些先决条件都满足，就应该第一时间想到分治法

### 排序

> 排序，就是让一组无序数据变成有序的过程。4 种常见的排序算法，包括*冒泡排序*、*插入排序*、*归并排序*以及*快速排序*

* 衡量一个排序算法的优劣
  - **时间复杂度**，具体包括，最好时间复杂度、最坏时间复杂度以及平均时间复杂度
  - **空间复杂度**，如果空间复杂度为 1，也叫作原地排序
  - **稳定性**，排序的稳定性是指相等的数据对象，在排序之后，顺序是否能保证不变

* 冒泡排序：稳定
  - 原理：从第一个数据开始，依次比较相邻元素的大小。如果前者大于后者，则进行交换操作，把大的元素往后交换。通过多轮迭代，直到没有交换操作为止
  - 性能：冒泡排序最好时间复杂度是 O(n)；最坏时间复杂度，是 O(n*n)；数组杂乱无章时，它的平均时间复杂度也是 O(n*n)；冒泡排序不需要额外的空间，所以空间复杂度是 O(1)。冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定的排序算法

* 插入排序：稳定
  - 原理：**选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空**。插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作
  - 性能：插入排序最好时间复杂度是 O(n)；插入排序最坏时间复杂度则需要 O(n*n)；插入排序的平均时间复杂度是 O(n*n)；插入排序不需要开辟额外的空间，所以空间复杂度是 O(1)；插入排序是稳定的排序算法

* 插入排序和冒泡排序算法的异同点
  - 相同点
    - 插入排序和冒泡排序的平均时间复杂度都是 O(n*n)，且都是稳定的排序算法，都属于原地排序
  - 差异点
    - 冒泡排序每轮的交换操作是动态的，所以需要三个赋值操作才能完成
    - 而插入排序每轮的交换动作会固定待插入的数据，因此只需要一步赋值操作

* 归并排序：稳定
  - 原理：原理其实就是分治法。首先将数组不断地二分，直到最后每个部分只包含 1 个数据。然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了
  - 性能：采用了二分的迭代方式，复杂度是 logn；执行频次与输入序列无关，因此，归并排序最好、最坏、平均时间复杂度都是 O(nlogn)；空间复杂度方面，由于每次合并的操作都需要开辟基于数组的临时内存空间，所以空间复杂度为 O(n)；归并排序合并的时候，相同元素的前后顺序不变，所以归并是稳定的排序算法

* 快速排序：不稳定
  - 原理：原理其实也是分治法。它的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序
  - 性能：在快排的最好时间的复杂度下，如果每次选取分区点时，都能选中中位数，把数组等分成两个，那么此时的时间复杂度和归并一样，都是 O(n*logn)；而在最坏的时间复杂度下，也就是如果每次分区都选中了最小值或最大值，得到不均等的两组。那么就需要 n 次的分区操作，每次分区平均扫描 n / 2 个元素，此时时间复杂度就退化为 O(n*n) 了；快速排序法在大部分情况下，统计上是很难选到极端情况的。因此它平均的时间复杂度是 O(n*logn)；快速排序法的空间方面，使用了交换法，因此空间复杂度为 O(1)；快速排序的分区过程涉及交换操作，所以快排是不稳定的排序算法

总结：如果对数据规模比较小的数据进行排序，可以选择时间复杂度为 O(n*n) 的排序算法；但对数据规模比较大的数据进行排序，就需要选择时间复杂度为 O(nlogn) 的排序算法了

### 动态规划

> 从数学的视角来看，动态规划是一种运筹学方法，是在多轮决策过程中的最优方法

* 什么是多轮决策？其实多轮决策的每一轮都可以看作是一个子问题。从分治法的视角来看，每个子问题必须相互独立。但在多轮决策中，这个假设显然不成立。这也是动态规划方法产生的原因之一。动态规划还有一个重要概念叫作状态
* 最短路径问题
* 基本方法：（k 表示多轮决策的第 k 轮）
  - **分阶段**，将原问题划分成几个子问题。一个子问题就是多轮决策的一个阶段，它们可以是不满足独立性的
  - **找状态**，选择合适的状态变量 S<sub>k</sub>。它需要具备描述多轮决策过程的演变，更像是决策可能的结果
  - **做决策**，确定决策变量 u<sub>k</sub>。每一轮的决策就是每一轮可能的决策动作
  - **状态转移方程**，这个步骤是动态规划最重要的核心，即 s<sub>k+1</sub>= u<sub>k</sub>(s<sub>k</sub>)
  - **定目标**，写出代表多轮决策目标的指标函数 V<sub>k,n</sub>
  - **寻找终止条件**
* 基本概念
  - **策略**，每轮的动作是决策，多轮决策合在一起常常被称为策略
  - **策略集合**，由于每轮的决策动作都是一个变量，这就导致合在一起的策略也是一个变量。我们通常会称所有可能的策略为策略集合。因此，动态规划的目标，也可以说是从策略集合中，找到最优的那个策略
* 一般而言，具有如下几个特征的问题，可以采用动态规划求解:
  - **最优子结构**，它的含义是，原问题的最优解所包括的子问题的解也是最优的。例如，某个策略使得 A 到 G 是最优的。假设它途径了 Fi，那么它从 A 到 Fi 也一定是最优的
  - **无后效性**，某阶段的决策，无法影响先前的状态。可以理解为今天的动作改变不了历史
  - **有重叠子问题**，也就是，子问题之间不独立。这个性质是动态规划区别于分治法的条件。如果原问题不满足这个特征，也是可以用动态规划求解的，无非就是杀鸡用了宰牛刀

### 通用解题的方法论

* **面对一个未知问题时，你可以从复杂度入手**。尝试去分析这个问题的时间复杂度上限是多少，也就是复杂度再高能高到哪里。这就是不计任何时间、空间损耗，采用暴力求解的方法去解题。然后分析这个问题的时间复杂度下限是多少，也就是时间复杂度再低能低到哪里。这就是你写代码的目标
* **接着，尝试去定位问题**。在分析出这两个问题之后，就需要去设计合理的数据结构和运用合适的算法思维，从暴力求解的方法去逼近写代码的目标了。在这里需要先定位问题，这个问题的类型就决定了采用哪种算法思维
* **最后，需要对数据操作进行分析**。例如：在这个问题中，需要对数据进行哪些操作（增删查），数据之间是否需要保证顺序或逆序？当分析出这些操作的步骤、频次之后，就可以根据不同数据结构的特性，去合理选择你所应该使用的那几种数据结构了

#### 宏观上的步骤总结为以下4步

* **复杂度分析**。估算问题中复杂度的上限和下限
* **定位问题**。根据问题类型，确定采用何种算法思维
* **数据操作分析**。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间
* **编码实现**

### 训练题

* 斐波那契数列（递归）
* 判断一个数组中是否存在某个数（二分查找）
* 求解最大公共子串（动态规划）
* 反转字符串中的单词（栈）
* 树的层序遍历（队列）
* 查找数据流中的中位数（大顶堆和小顶堆）
  - 大顶堆是一棵完全二叉树，它的性质是，父结点的数值比子结点的数值大
  - 小顶堆的性质与此相反，父结点的数值比子结点的数值小
* 删除排序数组中的重复项
* 查找两个有序数组合并后的中位数
* 判断数组中所有的数字是否只出现一次
* 找出数组中出现次数超过数组长度一半的元素
* 给定一个方格棋盘，从左上角出发到右下角有多少种方法（动态规划）: 在一个方格棋盘里，左上角是起点，右下角是终点。每次只能向右或向下，移向相邻的格子。同时，棋盘中有若干个格子是陷阱，不可经过，必须绕开行走