---
title: Data structure and algorithm
date: 2020-07-23
type: technology
category:
spoiler:
tags:
# readtime:
---

* `复杂度`: 复杂度是衡量代码运行效率的重要的度量因素。分为**时间复杂度**和**空间复杂度**
  - **它与具体的常系数无关**，O(n) 和 O(2n) 表示的是同样的复杂度
  - **复杂度相加的时候，选择高者作为结果**，也就是说 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度
  - **O(1) 也是表示一个特殊复杂度**，即任务与算例个数 n 无关

* `数据结构`：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度(常用的降低时间复杂度的方法有递归、二分法、排序算法、动态规划等)
  - **暴力解法**，在没有任何时间、空间约束下，完成代码任务的开发
  - **无效操作处理**，将代码中的无效计算、无效存储剔除，降低时间或空间复杂度
  - **时空转换**，设计合理数据结构，完成时间复杂度向空间复杂度的转移

* `数据操作`: 数据处理的基本操作只有 3 个，分别是**增**、**删**、**查**。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。几乎所有的数据处理，都是这些基本操作的组合和叠加。
  - **查找**: 看能否在数据结构中查找到这个元素，也就是判断元素是否出现过
    - 根据元素的位置或索引来查找
    - 根据元素的数值特征来查找
  - **新增**: 针对没有出现过的情况，新增这个元素
  - **改动**: 针对出现过的情况，需要对这个元素出现的次数加 1

* `栈`: 栈是一种特殊的线性表，栈的数据结点必须后进先出
  - **栈的基本操作**：压栈（push），出栈（pop）
  - **栈的案例**：
    - 左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配（左括号 ==> 压栈，右括号 ==> 出栈，如果栈为空则合法）
    - 浏览器后退和前进的功能：维护两个栈，分别用来支持后退和前进。当用户访问了一个新的页面，则对后退栈进行压栈操作。当用户后退了一个页面，则后退栈进行出栈，同时前进栈执行压栈。当用户前进了一个页面，则前进栈出栈，同时后退栈压栈

* `队列`: 队列也是一种特殊的线性表，特点是先进先出。通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列，在面对数据处理顺序非常敏感的问题时，队列一定是个不错的技术选型。
  - **两种存储方式**：顺序队列和链式队列
    - 顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储
    - 链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表
  - 循环队列：特殊变种

* `数组`: 数组是数据结构中的最基本结构。数组在内存中是连续存放的，数组内的数据，可以通过索引值直接取出得到
  - **数组增删查操作的特点**
    - 增加：若插入数据在最后，则时间复杂度为 O(1)；如果中间某处插入数据，则时间复杂度为 O(n)
    - 删除：对应位置的删除，扫描全数组，时间复杂度为 O(n)
    - 查找：如果只需根据索引值进行一次查找，时间复杂度是 O(1)。但是要在数组中查找一个数值满足指定条件的数据，则时间复杂度是 O(n)

* `字符串`: 字符串（string） 是由 n 个字符组成的一个有序整体（ n >= 0 ）。字符串的存储结构与线性表相同，也有顺序存储和链式存储两种

* `树`: 树是由结点和边组成的，不存在环的一种数据结构。树满足递归定义的特性。也就是说，如果一个数据结构是树结构，那么剔除掉根结点后，得到的若干个子结构也是树，通常称作子树。
  - 遍历
    - **前序遍历**，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树
    - **中序遍历**，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树
    - **后序遍历**，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身

* `二叉树`: 在树的大家族中，有一种被高频使用的特殊树，它就是二叉树。在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点
  - **满二叉树**：定义为除了叶子结点外，所有结点都有 2 个子结点
  - **完全二叉树**：定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列

* `哈希表`: 哈希表名字源于 Hash，也可以叫作散列表。哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来（`如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想`）
  - 常用的设计哈希函数的方法:
    - 直接定制法：哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数
    - 数字分析法：假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址
    - 平方取中法：如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址
    - 折叠法：如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址
    - 除留余数法：预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p
  - 解决哈希冲突：
    - 开放定址法：即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中（常用的探测方法是线性探测法）
    - 链地址法：将哈希地址相同的记录存储在一张线性链表中

* `递归`: 数学模型其实就是数学归纳法。在数学与计算机科学中，递归 （Recursion)）是指在函数的定义中使用函数自身的方法，直观上来看，就是某个函数自己调用自己（`递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决`）
  - 递归有两层含义:
    - 递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题。并且这些子问题可以用完全相同的解题思路来解决；
    - 归问题的演化过程是一个对原问题从大到小进行拆解的过程，并且会有一个明确的终点（临界点）。一旦原问题到达了这个临界点，就不用再往更小的问题上拆解了。最后，从这个临界点开始，把小问题的答案按照原路返回，原问题便得以解决
  - 这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况
  - 递归的实现包含了两个部分，一个是递归主体，另一个是终止条件
  - 递归的案例：汉诺塔问题，斐波那契数列，分治策略，快速排序